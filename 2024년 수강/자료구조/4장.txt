 * 중첩 클래스
하나의 클래스가 
다른 클래서 정의 안에서 정의

외부로부터 접근되는 것을 방지

재사용성은 좋지 x


 * 단순 연결 리스트
배열을 말함
순차 표현

연속된 원소들이
일정한 거리만큼 떨어져서 저장되어 있음

 1. 임의 원소 접근
 2. 스택 or 큐의 원소 삽입, 삭제
에 적합

순서 리스트에서
임의 원소의 삽입, 삭제 비용이 큼


 * 연결된 표현  linked
노드로 구성

노드는
 1. 데이터
 2. 링크 (포인터)
로 구성

각 원소들은 메모리의 어떤 곳에나 위치
링크를 통해 다른 원소를 찾아내는 것


 * 노드 삽입
 1. 현재 사용하고 있지 않은 노드 할당 (노드 new)
 2. 노드 new의 데이터 필드에 데이터 입력
 3. 노드 new의 링크 필드가 다음 노드를 가리키도록 함
 4. 노드 new의 이전 링크가 노드 new를 가리키도록 함

이럴 경우 삽입할 때 다른 원소들의 이동이 불필요하다

link 필드를 위한 저장 공간이 추가로 필요

뒤에서부터 연결하는 것이 핵심이다

(그림 첨부)


 * 노드 삭제

맨 앞 삭제의 경우
 1. first = first->link
 2. temp = first

node01 -> node02 -> node03으로 연결되어 있고 node02를 삭제하고 싶은 경우
 1. node01의 링크 필드가 node03을 가리키게 하고
 2. node02를 삭제

항상 연결고리를 잘 생각해야 한다
temp와 prev를 이용

그림을 그리면서 코딩하는 것이 좋다


 * 체인 (단순 연결 리스트)
노드를 관리하는 클래스

하나의 링크 필드를 가진 노드들을
순차적으로 연결한 구조

노드 클래스는 체인 클래스를
friend 선언해야 한다
그래야 체인에서 노드에 접근할 수 있기 때문

체인은 개념적으로 여러 노드들을 포함하지만
물리적으로 첫 번째 노드인 first만 포함해도 충분
friend 선언이 되어 있어 다른 노드에도 접근할 수 있기 때문

main()이 직접 체인에 접근하지 않으므로
체인이 망가질 일이 없다

체인의 구성
 1. first
 2. 체인 조작 연산

 first
체인의 첫 번째 노드를 지시하고 있는 접근 포인터
체인 클래스의 전용 데이터 멤버


<<체인 클래스 구현 코드>>
class Chain;

class Node {
  friend class Chain;

  private :
    int data;
    Node * link;
};

class Chain {
  public :
    // 리스트 조작 연산

  private :
    Node * first;
};
..~~~~..


 * 체인 조작 연산
 1. 노드 리스트 생성
 2. 노드 삽입
 3. 노드 삭제

다 Chain에 있는 것


 * 노드 리스트 생성
 1. 두 번째 노드를 생성하고 초기화
 2. 첫번째 노드를 생성하고 초기화

<<노드 리스트 생성 구현 코드>>
void Create() {
  Node * second = new Node();  // 두 번째 노드를 생성하고 초기화

  first = new Node();  // 첫 번째 노드를 생성하고 초기화
}
..~~~~..

 * 노드 삽입
주소를 입력받으면
그 주소의 다음에 삽입하는 것

순서는
 1. 노드 new를 만들고
 2. 노드 new의 링크 필드에 기존 노드 address의 링크 필드를 할당
 3. 노드 address의 링크 필드에 노드 new의 주소를 할당

<<노드 삽입 구현 코드>>
void Insert(Node * address) {
  if (first)  // first가 있는 경우
    address->link = new Node();
  else  // first가 없는 경우
    first = new Node();
}
..~~~~..


 * 노드 삭제
연결을 먼저 시켜주고 삭제한다

삭제하고자 하는 노드의 주소와
그 노드의 이전 주소가 필요하다
링크 연결을 위한 것

<<노드 삭제 구현 코드>>
void Delete(Node * address, Node *prev) {
  if (address == first)  // 첫 노드를 삭제하는 경우
    first = first->link;
  else
    prev->link = address->link;

  delete address;
}
..~~~~..


 * 클래스 템플릿

template <class T>
class 클래스템플릿이름 {}

이 때 <class T>, <typename T> 모두 사용 가능

template <typename T1, typename T2>
class 클래스템플릿이름 {}

클래스 템플릿의 객체 생성은
클래스템플릿이름<자료형> 객체명();

ex)
template <typename T>
class Car{};

int main() {
  Car<int> = myCar();

  return 0;
}


 * 체인 반복자
 반복자  iterator
컨테이너 클래스의 모든 원소를 순회하는데
사용되는 객체

 컨테이너 클래스에 대한 연산
 1. 컨테이너 클래스의 모든 데이터 출력
 2. 컨테이너 클래스의 최대, 최소, 평균, 중간 값을 계산
 3. 컨테이너 클래스의 값의 합, 곱, 제곱의 합을 계산
 4. 컨테이너 클래스의 값 중 어떤 조건을 만족하는 것을 검색
 5. 컨테이너 클래스의 값 중 어떤 함수의 값이 최대값이 되는 원소 검색

컨테이너 클래스의 구현 방식에 따라
내부 구조가 상이하다

그러나 하나의 일관된 방법으로 구현하면 좋다
사용자가 구현 방법을 모르고 사용하는 것이 좋으므로


 *  반복자  iterator
컨테이너 클래스의 모든 원소를 순회하는데
사용되는 객체

객체의 원소에 대한 포인터

객체의 원소를 하나씩 지나가도록 지원

반복자 클래스의 객체를 통해
객체의 원소를 하나씩 지나가는 것

 전방 반복자
앞으로 한 칸 이동하는 반복자
++을 지원


 * 원형 리스트  circular list
체인에서 마지막 노드의 link 필드가
첫 번째 노드를 가리킴

접근 포인터 first를 이용해서
원형 리스트를 구분 및 사용

but 접근 포인터가 마지막 노드를 가리키는 것이 더 편리하다
접근 포인터 last를 사용

즉,
head == 마지막 노드 주소
head->link == 첫번째 노드 주소


 * 연결 스택 
접근 포인터로 top 사용
top은 스택의 맨 위 노드를 가리키는 포인터
초기에는 top을 0으로 설정


 * 연결 큐

 front
큐의 처음 노드를 가리키는 접근 포인터

 rear
큐의 마지막 노드를 가리키는 접근 포인터

초기에는
front와 rear을 0으로 설정


 * 이중 연결 리스트  doubly linked list
각 노드는
전방과 후방을 가리키는 두개의 링크를 가짐


